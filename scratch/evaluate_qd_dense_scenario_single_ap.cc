/*
 * Copyright (c) 2015-2020 IMDEA Networks Institute
 * Author: Hany Assasa <hany.assasa@gmail.com>
 */
#include "ns3/applications-module.h"
#include "ns3/core-module.h"
#include "ns3/flow-monitor-module.h"
#include "ns3/internet-module.h"
#include "ns3/mobility-module.h"
#include "ns3/network-module.h"
#include "ns3/spectrum-module.h"
#include "ns3/wifi-module.h"
#include "common-functions.h"
#include <iomanip>
#include <sstream>

/**
 * Simulation Objective:
 * Evaluate the performance and behaviour of the IEEE 802.11ad standard over Q-D channel model.
 * Both DMG AP and DMG STAs use a parametric codebook generated by our IEEE 802.11ad Codebook Generator in MATLAB.
 * Each device uses an URA antenna array of 2x8 Elements. The channel model is generated by our Q-D Realization software.
 * We use this script to generate the dense Scenario results in our paper "High Fidelity Simulation of IEEE 802.11ad
 * in ns-3 Using a Quasi-deterministic Channel Model".
 *
 * Network Topology:
 * The network consists of a single access point placed in the center of a room. The DMG AP is surrounded by 10 DMG STAs.
 * These DMG STAs are placed on the circumference of a circle where the DMG AP is in the center of this circle.
 *
 *
 *                                 DMG STA (10)
 *
 *
 *
 *                  DMG STA (1)                     DMG STA (9)
 *

 *
 *          DMG STA (2)                                     DMG STA (8)
 *
 *                                    DMG AP
 *
 *          DMG STA (3)                                     DMG STA (7)
 *

 *
 *                  DMG STA (4)                     DMG STA (6)
 *

 *
 *                                  DMG STA (5)
 *
 *
 * Running the Simulation:
 * ./waf --run "evaluate_qd_dense_scenario_single_ap"
 *
 * Simulation Output:
 * The simulation generates the following traces:
 * 1. PCAP traces for each station.
 * 2. SLS results for visualization in Q-D Visualizer.
 * 3. SNR Information for TXSS phases.
 * 4. SNR Information for data packets if enabled.
 */

NS_LOG_COMPONENT_DEFINE ("EvaluateQdDenseScenarioSingleAP");

using namespace ns3;
using namespace std;

/** Simulation Arguments **/
string applicationType = "onoff";             /* Type of the Tx application */
string socketType = "ns3::UdpSocketFactory";  /* Socket Type (TCP/UDP) */
uint32_t packetSize = 1448;                   /* Application payload size in bytes. */
string dataRate = "300Mbps";                  /* Application data rate. */
string tcpVariant = "NewReno";                /* TCP Variant Type. */
uint32_t maxPackets = 0;                      /* Maximum Number of Packets */
string msduAggSize = "max";                   /* The maximum aggregation size for A-MSDU in Bytes. */
string mpduAggSize = "max";                   /* The maximum aggregation size for A-MPDU in Bytes. */
double simulationTime = 10;                   /* Simulation time in seconds. */
bool csv = false;                             /* Enable CSV output. */
bool reportDataSnr = true;                    /* Report Data Packets SNR. */

/**  Variables **/
CommunicationPairList communicationPairList;  /* List of communicating devices. */
Ptr<QdPropagationEngine> qdPropagationEngine; /* Q-D Propagation Engine. */

/*** Beamforming CBAP ***/
uint16_t biThreshold = 10;                    /* BI Threshold to trigger TXSS TXOP. */
std::map<Mac48Address, uint16_t> biCounter;   /* Number of beacon intervals that have passed. */

void
CalculateThroughput (void)
{
  double totalThr = 0;
  double thr;
  if (!csv)
    {
      string duration = to_string_with_precision<double> (Simulator::Now ().GetSeconds () - 0.1, 1)
                      + " - " + to_string_with_precision<double> (Simulator::Now ().GetSeconds (), 1);
      std::cout << std::left << std::setw (12) << duration;
      for (CommunicationPairList_I it = communicationPairList.begin (); it != communicationPairList.end (); it++)
        {
          thr = CalculateSingleStreamThroughput (it->second.packetSink, it->second.totalRx, it->second.throughput);
          totalThr += thr;
        std::cout << std::left << std::setw (12) << thr;
        }
      std::cout << std::left << std::setw (12) << totalThr << std::endl;
    }
  else
    {
      std::cout << to_string_with_precision<double> (Simulator::Now ().GetSeconds (), 1);
      for (CommunicationPairList_I it = communicationPairList.begin (); it != communicationPairList.end (); it++)
        {
          thr = CalculateSingleStreamThroughput (it->second.packetSink, it->second.totalRx, it->second.throughput);
          totalThr += thr;
        std::cout << "," << thr;
        }
      std::cout << "," << totalThr << std::endl;
    }
  Simulator::Schedule (MilliSeconds (100), &CalculateThroughput);
}

void
StationAssoicated (Ptr<Node> node, Ptr<DmgWifiMac> staWifiMac, Mac48Address address, uint16_t aid)
{
  if (!csv)
    {
      std::cout << "DMG STA " << staWifiMac->GetAddress () << " associated with DMG PCP/AP " << address
                << ", Association ID (AID) = " << aid << std::endl;
    }
  CommunicationPairList_I it = communicationPairList.find (node->GetId ());
  if (it != communicationPairList.end ())
    {
      it->second.startTime = Simulator::Now ();
      it->second.srcApp->StartApplication ();
    }
  else
    {
      NS_FATAL_ERROR ("Could not find application to run.");
    }
}

void
StationDeassoicated (Ptr<Node> node, Ptr<DmgWifiMac> staWifiMac, Mac48Address address)
{
  if (!csv)
    {
      std::cout << "DMG STA " << staWifiMac->GetAddress () << " deassociated from DMG PCP/AP " << address << std::endl;
    }
  CommunicationPairList_I it = communicationPairList.find (node->GetId ());
  if (it != communicationPairList.end ())
    {
      it->second.srcApp->StopApplication ();
    }
  else
    {
      NS_FATAL_ERROR ("Could not find application to delete.");
    }
}

CommunicationPair
InstallApplications (Ptr<Node> srcNode, Ptr<Node> dstNode, Ipv4Address address, uint8_t appNumber)
{
  CommunicationPair commPair;

  /* Install TCP/UDP Transmitter on the source node */
  Address dest (InetSocketAddress (address, 9000 + appNumber));
  ApplicationContainer srcApp;
  if (applicationType == "onoff")
    {
      OnOffHelper src (socketType, dest);
      src.SetAttribute ("MaxPackets", UintegerValue (maxPackets));
      src.SetAttribute ("PacketSize", UintegerValue (packetSize));
      src.SetAttribute ("OnTime", StringValue ("ns3::ConstantRandomVariable[Constant=1e6]"));
      src.SetAttribute ("OffTime", StringValue ("ns3::ConstantRandomVariable[Constant=0]"));
      src.SetAttribute ("DataRate", DataRateValue (DataRate (dataRate)));
      srcApp = src.Install (srcNode);
    }
  else if (applicationType == "bulk")
    {
      BulkSendHelper src (socketType, dest);
      srcApp = src.Install (srcNode);
    }
  srcApp.Start (Seconds (simulationTime + 1));
  srcApp.Stop (Seconds (simulationTime));
  commPair.srcApp = srcApp.Get (0);

  /* Install Simple TCP/UDP Server on the destination node */
  PacketSinkHelper sinkHelper (socketType, InetSocketAddress (Ipv4Address::GetAny (), 9000 + appNumber));
  ApplicationContainer sinkApp = sinkHelper.Install (dstNode);
  commPair.packetSink = StaticCast<PacketSink> (sinkApp.Get (0));
  sinkApp.Start (Seconds (0.0));

  return commPair;
}

void
SLSCompleted (Ptr<DmgWifiMac> wifiMac, SlsCompletionAttrbitutes attributes)
{
  if (!csv)
    {
      std::cout << "DMG STA " << wifiMac->GetAddress ()
                << " completed SLS phase with DMG STA " << attributes.peerStation << std::endl;
      std::cout << "Best Tx Antenna Configuration: AntennaID=" << uint16_t (attributes.antennaID)
                << ", SectorID=" << uint16_t (attributes.sectorID) << std::endl;
    }
}

void
DataTransmissionIntervalStarted (Ptr<DmgStaWifiMac> wifiMac, Mac48Address address, Time)
{
  if (wifiMac->IsAssociated ())
    {
      uint16_t counter = biCounter[address];
      counter++;
      if (counter == biThreshold)
        {
          wifiMac->Perform_TXSS_TXOP (wifiMac->GetBssid ());
          counter = 0;
        }
      biCounter[address] = counter;
    }
}

void
MacRxOk (Ptr<DmgWifiMac> WifiMac, Ptr<OutputStreamWrapper> stream,
         WifiMacType type, Mac48Address address, double snrValue)
{
  if ((type == WIFI_MAC_QOSDATA) && reportDataSnr)
    {
      *stream->GetStream () << Simulator::Now ().GetNanoSeconds () << ","
                            << address << ","
                            << WifiMac->GetAddress () << ","
                            << snrValue << std::endl;
    }
  else if ((type == WIFI_MAC_EXTENSION_DMG_BEACON) || (type == WIFI_MAC_CTL_DMG_SSW) ||
      (type == WIFI_MAC_CTL_DMG_SSW_FBCK) || (type == WIFI_MAC_CTL_DMG_SSW_ACK))
    {
      *stream->GetStream () << Simulator::Now ().GetNanoSeconds () << ","
                            << address << ","
                            << WifiMac->GetAddress () << ","
                            << snrValue << std::endl;
    }
}

int
main (int argc, char *argv[])
{
  uint32_t bufferSize = 131072;                   /* TCP Send/Receive Buffer Size. */
  bool enableRts = false;                         /* Flag to indicate if RTS/CTS handskahre is enabled or disabled. */
  uint32_t rtsThreshold = 0;                      /* RTS/CTS handshare threshold. */
  string queueSize = "4000p";                     /* Wifi MAC Queue Size. */
  bool frameCapture = false;                      /* Use a frame capture model. */
  double frameCaptureMargin = 10;                 /* Frame capture margin in dB. */
  string phyMode = "DMG_MCS12";                   /* Type of the Physical Layer. */
  bool verbose = false;                           /* Print Logging Information. */
  bool pcapTracing = false;                       /* PCAP Tracing is enabled or not. */
  uint32_t snapshotLength = std::numeric_limits<uint32_t>::max (); /* The maximum PCAP Snapshot Length */
  uint16_t numSTAs = 10;                          /* The number of DMG STAs. */
  string qdChannelFolder = "DenseScenario";       /* The name of the folder containing the QD-Channel files. */
  string directory = "Traces/";                   /* Path to the directory where to store the results. */

  /* Command line argument parser setup. */
  CommandLine cmd;
  cmd.AddValue ("applicationType", "Type of the Tx Application: onoff or bulk", applicationType);
  cmd.AddValue ("packetSize", "Application packet size in bytes", packetSize);
  cmd.AddValue ("dataRate", "Application data rate", dataRate);
  cmd.AddValue ("maxPackets", "Maximum number of packets to send", maxPackets);
  cmd.AddValue ("tcpVariant", TCP_VARIANTS_NAMES, tcpVariant);
  cmd.AddValue ("socketType", "Type of the Socket (ns3::TcpSocketFactory, ns3::UdpSocketFactory)", socketType);
  cmd.AddValue ("bufferSize", "TCP Buffer Size (Send/Receive) in Bytes", bufferSize);
  cmd.AddValue ("msduAggSize", "The maximum aggregation size for A-MSDU in Bytes", msduAggSize);
  cmd.AddValue ("mpduAggSize", "The maximum aggregation size for A-MPDU in Bytes", mpduAggSize);
  cmd.AddValue ("enableRts", "Enable or disable RTS/CTS handshake", enableRts);
  cmd.AddValue ("rtsThreshold", "The RTS/CTS threshold value", rtsThreshold);
  cmd.AddValue ("queueSize", "The maximum size of the Wifi MAC Queue", queueSize);
  cmd.AddValue ("frameCapture", "Use a frame capture model", frameCapture);
  cmd.AddValue ("frameCaptureMargin", "Frame capture model margin in dB", frameCaptureMargin);
  cmd.AddValue ("phyMode", "802.11ad PHY Mode", phyMode);
  cmd.AddValue ("verbose", "turn on all WifiNetDevice log components", verbose);
  cmd.AddValue ("simulationTime", "Simulation time in seconds", simulationTime);
  cmd.AddValue ("directory", "Path to the directory where we store the results", directory);
  cmd.AddValue ("reportDataSnr", "Report SNR for data packets = True or for BF Control Packets = False", reportDataSnr);
  cmd.AddValue ("qdChannelFolder", "The name of the folder containing the QD-Channel files", qdChannelFolder);
  cmd.AddValue ("numSTAs", "The number of DMG STA", numSTAs);
  cmd.AddValue ("pcap", "Enable PCAP Tracing", pcapTracing);
  cmd.AddValue ("snapshotLength", "The maximum PCAP snapshot length in bytes", snapshotLength);
  cmd.AddValue ("csv", "Enable CSV output instead of plain text. This mode will suppress all the messages related statistics and events.", csv);
  cmd.Parse (argc, argv);

  /* Validate A-MSDU and A-MPDU values */
  ValidateFrameAggregationAttributes (msduAggSize, mpduAggSize);
  /* Configure RTS/CTS and Fragmentation */
  ConfigureRtsCtsAndFragmenatation (enableRts, rtsThreshold);
  /* Wifi MAC Queue Parameters */
  ChangeQueueSize (queueSize);

  /*** Configure TCP Options ***/
  ConfigureTcpOptions (tcpVariant, packetSize, bufferSize);

  /**** Set up Channel ****/
  Ptr<MultiModelSpectrumChannel> spectrumChannel = CreateObject<MultiModelSpectrumChannel> ();
  qdPropagationEngine = CreateObject<QdPropagationEngine> ();
  qdPropagationEngine->SetAttribute ("QDModelFolder", StringValue ("WigigFiles/QdChannel/" + qdChannelFolder + "/"));
  Ptr<QdPropagationLossModel> lossModelRaytracing = CreateObject<QdPropagationLossModel> (qdPropagationEngine);
  Ptr<QdPropagationDelayModel> propagationDelayRayTracing = CreateObject<QdPropagationDelayModel> (qdPropagationEngine);
  spectrumChannel->AddSpectrumPropagationLossModel (lossModelRaytracing);
  spectrumChannel->SetPropagationDelayModel (propagationDelayRayTracing);

  /**** Setup physical layer ****/
  SpectrumDmgWifiPhyHelper spectrumWifiPhy = SpectrumDmgWifiPhyHelper::Default ();
  spectrumWifiPhy.SetChannel (spectrumChannel);
  /* All nodes transmit at 10 dBm == 10 mW, no adaptation */
  spectrumWifiPhy.Set ("TxPowerStart", DoubleValue (10.0));
  spectrumWifiPhy.Set ("TxPowerEnd", DoubleValue (10.0));
  spectrumWifiPhy.Set ("TxPowerLevels", UintegerValue (1));
  if (frameCapture)
    {
      /* Frame Capture Model */
      spectrumWifiPhy.Set ("FrameCaptureModel", StringValue ("ns3::SimpleFrameCaptureModel"));
      Config::SetDefault ("ns3::SimpleFrameCaptureModel::Margin", DoubleValue (frameCaptureMargin));
    }
  /* Set the operational channel */
  spectrumWifiPhy.Set ("ChannelNumber", UintegerValue (2));

  /* Create 1 DMG PCP/AP */
  NodeContainer apWifiNode;
  apWifiNode.Create (1);
  /* Create 10 DMG STAs */
  NodeContainer staWifiNodes;
  staWifiNodes.Create (numSTAs);

  /**** WifiHelper is a meta-helper: it helps creates helpers ****/
  DmgWifiHelper wifi;

  /* Turn on logging */
  if (verbose)
    {
      wifi.EnableLogComponents ();
      LogComponentEnable ("EvaluateQdDenseScenarioSingleAP", LOG_LEVEL_ALL);
    }

  /* Add a DMG upper mac */
  DmgWifiMacHelper wifiMacHelper = DmgWifiMacHelper::Default ();

  Ssid ssid = Ssid ("DenseScenario");
  wifiMacHelper.SetType ("ns3::DmgApWifiMac",
                         "Ssid", SsidValue (ssid),
                         "BE_MaxAmpduSize", StringValue (mpduAggSize),
                         "BE_MaxAmsduSize", StringValue (msduAggSize),
                         "SSSlotsPerABFT", UintegerValue (8), "SSFramesPerSlot", UintegerValue (13),
                         "BeaconInterval", TimeValue (MicroSeconds (102400)),
                         "ATIPresent", BooleanValue (false));

  /* Create Wifi Network Devices (WifiNetDevice) */
  NetDeviceContainer apDevice;
  apDevice = wifi.Install (spectrumWifiPhy, wifiMacHelper, apWifiNode, false);

  wifiMacHelper.SetType ("ns3::DmgStaWifiMac",
                         "BE_MaxAmpduSize", StringValue (mpduAggSize),
                         "BE_MaxAmsduSize", StringValue (msduAggSize),
                         "Ssid", SsidValue (ssid), "ActiveProbing", BooleanValue (false));

  NetDeviceContainer staDevices;
  staDevices = wifi.Install (spectrumWifiPhy, wifiMacHelper, staWifiNodes, false);

  /** Install Codebooks **/

  /* Set Parametric Codebook for the DMG PCPs/AP */
  CodebookParametricHelper codebookHelper;
  codebookHelper.SetCodebookParameters ("FileName", StringValue ("WigigFiles/Codebook/CODEBOOK_URA_AP_28x.txt"));
  codebookHelper.Install (apDevice);

  /* Set Parametric Codebook for all the DMG STAs */
  codebookHelper.SetCodebookParameters ("FileName", StringValue ("WigigFiles/Codebook/CODEBOOK_URA_STA_28x.txt"));
  codebookHelper.Install (staDevices);

  /* Setting mobility model for AP */
  MobilityHelper mobilityAp;
  mobilityAp.SetMobilityModel ("ns3::ConstantPositionMobilityModel");
  mobilityAp.Install (apWifiNode);

  /* Setting mobility model for STA */
  MobilityHelper mobilitySta;
  mobilitySta.SetMobilityModel ("ns3::ConstantPositionMobilityModel");
  mobilitySta.Install (staWifiNodes);

  /* Internet stack*/
  InternetStackHelper stack;
  stack.Install (apWifiNode);
  stack.Install (staWifiNodes);

  Ipv4AddressHelper address;
  address.SetBase ("10.0.0.0", "255.255.255.0");
  Ipv4InterfaceContainer apInterface;
  apInterface = address.Assign (apDevice);
  Ipv4InterfaceContainer staInterfaces;
  staInterfaces = address.Assign (staDevices);

  /* We do not want any ARP packets */
  PopulateArpCache ();

  /** Install Applications **/
  /* DMG STA -->  DMG AP */
  for (uint32_t i = 0; i < staWifiNodes.GetN (); i++)
    {
      communicationPairList[staWifiNodes.Get (i)->GetId ()] = InstallApplications (staWifiNodes.Get (i), apWifiNode.Get (0),
                                                                                   apInterface.GetAddress (0), i);
    }

  /* Print Traces */
  if (pcapTracing)
    {
      spectrumWifiPhy.SetPcapDataLinkType (SpectrumWifiPhyHelper::DLT_IEEE802_11_RADIO);
      spectrumWifiPhy.EnablePcap ("Traces/AccessPoint", apDevice, false);
      spectrumWifiPhy.EnablePcap ("Traces/STA", staDevices, false);
    }

  /* Get SLS Traces */
  Ptr<SlsBeamformingTraceHelper> slsTracerHelper
      = Create<SlsBeamformingTraceHelper> (qdPropagationEngine, directory, std::to_string (RngSeedManager::GetRun ()));
  slsTracerHelper->ConnectTrace (apDevice);
  slsTracerHelper->ConnectTrace (staDevices);

  /* Get SNR Traces */
  AsciiTraceHelper ascii;
  Ptr<OutputStreamWrapper> snrStream = ascii.CreateFileStream (directory + "snrValues.csv");
  *snrStream->GetStream () << "TIME,SRC,DST,SNR" << std::endl;

  Ptr<WifiNetDevice> wifiNetDevice;
  Ptr<DmgApWifiMac> apWifiMac;
  Ptr<DmgStaWifiMac> staWifiMac;
  Ptr<WifiRemoteStationManager> remoteStationManager;

  /* Connect DMG STA traces */
  for (uint32_t i = 0; i < staDevices.GetN (); i++)
    {
      wifiNetDevice = StaticCast<WifiNetDevice> (staDevices.Get (i));
      staWifiMac = StaticCast<DmgStaWifiMac> (wifiNetDevice->GetMac ());
      remoteStationManager = wifiNetDevice->GetRemoteStationManager ();
      remoteStationManager->TraceConnectWithoutContext ("MacRxOK", MakeBoundCallback (&MacRxOk, staWifiMac, snrStream));
      staWifiMac->TraceConnectWithoutContext ("Assoc", MakeBoundCallback (&StationAssoicated, staWifiNodes.Get (i), staWifiMac));
      staWifiMac->TraceConnectWithoutContext ("DeAssoc", MakeBoundCallback (&StationDeassoicated, staWifiNodes.Get (i), staWifiMac));
      staWifiMac->TraceConnectWithoutContext ("SLSCompleted", MakeBoundCallback (&SLSCompleted, staWifiMac));
      staWifiMac->TraceConnectWithoutContext ("DTIStarted", MakeBoundCallback (&DataTransmissionIntervalStarted, staWifiMac));
      biCounter[staWifiMac->GetAddress ()] = 0;
    }

  /* Connect DMG PCP/AP trace */
  wifiNetDevice = StaticCast<WifiNetDevice> (apDevice.Get (0));
  apWifiMac = StaticCast<DmgApWifiMac> (wifiNetDevice->GetMac ());
  remoteStationManager = wifiNetDevice->GetRemoteStationManager ();
  apWifiMac->TraceConnectWithoutContext ("SLSCompleted", MakeBoundCallback (&SLSCompleted, apWifiMac));
  remoteStationManager->TraceConnectWithoutContext ("MacRxOK", MakeBoundCallback (&MacRxOk, apWifiMac, snrStream));

  /* Enable Traces */
  if (pcapTracing)
    {
      spectrumWifiPhy.SetPcapDataLinkType (YansWifiPhyHelper::DLT_IEEE802_11_RADIO);
      spectrumWifiPhy.SetSnapshotLength (snapshotLength);
      spectrumWifiPhy.EnablePcap ("Traces/AccessPoint", apDevice, false);
      spectrumWifiPhy.EnablePcap ("Traces/STA", staDevices, false);
    }

  /* Install FlowMonitor on all nodes */
  FlowMonitorHelper flowmon;
  Ptr<FlowMonitor> monitor = flowmon.InstallAll ();

  /* Print Output */
  if (!csv)
    {
      std::cout << "Application Layer Throughput per Communicating Pair [Mbps]" << std::endl;
      std::cout << std::left << std::setw (12) << "Time [s]";
      string columnName;
      for (uint8_t i = 0; i < communicationPairList.size (); i++)
        {
          columnName = "Pair (" + std::to_string (i + 1) + ")";
          std::cout << std::left << std::setw (12) << columnName;
        }
       std::cout << std::left << std::setw (12) << "Total" << std::endl;
    }

  /* Schedule Throughput Calulcations */
  Simulator::Schedule (Seconds (0.1), &CalculateThroughput);

  Simulator::Stop (Seconds (simulationTime + 0.101));
  Simulator::Run ();
  Simulator::Destroy ();

  if (!csv)
    {
      PrintApplicationLayerAndFlowMonitorStatistics (flowmon, monitor, communicationPairList, applicationType, simulationTime - 0.1);
    }

  return 0;
}
