/*
 * Copyright (c) 2015-2019 IMDEA Networks Institute
 * Author: Hany Assasa <hany.assasa@gmail.com>
 */
#include "ns3/applications-module.h"
#include "ns3/core-module.h"
#include "ns3/flow-monitor-module.h"
#include "ns3/internet-module.h"
#include "ns3/mobility-module.h"
#include "ns3/network-module.h"
#include "ns3/spectrum-module.h"
#include "ns3/wifi-module.h"
#include "common-functions.h"
#include <iomanip>
#include <sstream>

/**
 * Simulation Objective:
 * This script is used to evaluate the performance and behaviour of the IEEE 802.11ad for Multi-BSS i.e. Multi-AP
 * deployment over Q-D channel model. DMG APs and DMG STAs use a parametric codebook generated by our IEEE 802.11ad
 * Codebook Generator in MATLAB. Each device uses an URA antenna array of 2x8 Elements. The channel model is generated
 * by our Q-D Realization software. We use this script to generate the Spatial Sharing results in our paper
 * "High Fidelity Simulation of IEEE 802.11ad in ns-3 Using a Quasi-deterministic Channel Model".
 *
 * Network Topology:
 * The scenario consists of variable number of parallel links. The distance between every link is dependent on the
 * Q-D realization files utilized for this simulation.
 *
 *
 *          DMG AP_1  (0, +1)               DMG AP_2  (+1, +1)    ------   DMG AP_N  (+1, +1)
 *
 *                 ^                               ^                              ^
 *                 |                               |                              |
 *                 |       <--- distance --->      |              ------          |
 *                 |                               |                              |
 *
 *          DMG STA_1 (0, -1)               DMG STA_2 (+1, -1)    ------   DMG STA_2 (+1, -1)
 *
 *
 * Simulation Description:
 * Once a DMG STA is associated with its corresponding DMG PCP/ACP, it generates multiple TCP flows towards that DMG PCP/AP.
 * We use DMG Error Model generated using MATLAB WLAN Toolbox.
 *
 * Running Simulation:
 * To use this script simply type the following run command:./waf --run "evaluate_qd_channel_spatial_sharing --enableMobility=false"

 * ./waf --run "evaluate_qd_channel_spatial_sharing --enableMobility=true"
 *
 * Simulation Output:
 */

NS_LOG_COMPONENT_DEFINE ("EvaluateMultiBSSOperation");

using namespace ns3;
using namespace std;

/* Type definitions */
struct CommunicationPair
{
  Ptr<Application> srcApp;
  Ptr<PacketSink> packetSink;
  uint64_t totalRx = 0;
  double throughput = 0;
  Time startTime;
};

/* Tracing */
typedef std::map<Mac48Address, uint32_t> MAP_MAC2ID;
typedef MAP_MAC2ID::iterator MAP_MAC2ID_I;
MAP_MAC2ID map_Mac2ID;
Ptr<QdPropagationLossModel> lossModelRaytracing;                         //!< Q-D Channel Tracing Model.

struct Parameters : public SimpleRefCount<Parameters>
{
  uint32_t srcNodeID;
  Ptr<DmgWifiMac> wifiMac;
};

typedef std::map<Ptr<Node>, CommunicationPair> CommunicationPairList;
typedef CommunicationPairList::iterator CommunicationPairList_I;
typedef CommunicationPairList::const_iterator CommunicationPairList_CI;

/** Simulation Arguments **/
string applicationType = "onoff";             /* Type of the Tx application */
string socketType = "ns3::UdpSocketFactory";  /* Socket Type (TCP/UDP) */
uint32_t packetSize = 1448;                   /* Application payload size in bytes. */
string dataRate = "300Mbps";                  /* Application data rate. */
string tcpVariant = "NewReno";                /* TCP Variant Type. */
uint32_t maxPackets = 0;                      /* Maximum Number of Packets */
uint32_t msduAggregationSize = 7935;          /* The maximum aggregation size for A-MSDU in Bytes. */
uint32_t mpduAggregationSize = 262143;        /* The maximum aggregation size for A-MPDU in Bytes. */
double simulationTime = 10;                   /* Simulation time in seconds. */
bool csv = true;                             /* Enable CSV output. */
bool enableJitter = true;                     /* Enable Beacon Interval Jitter to randomize Beacon Interval start time. */
std::string beaconJitter = "ns3::UniformRandomVariable[Min=0|Max=10]";

/**  Applications **/
CommunicationPairList communicationPairList;    /* List of communicating devices. */

template <typename T>
std::string to_string_with_precision (const T a_value, const int n = 6)
{
  std::ostringstream out;
  out.precision (n);
  out << std::fixed << a_value;
  return out.str ();
}

double
CalculateSingleStreamThroughput (Ptr<PacketSink> sink, uint64_t &lastTotalRx, double &averageThroughput)
{
  double thr = (sink->GetTotalRx () - lastTotalRx) * (double) 8 / 1e5;     /* Convert Application RX Packets to MBits. */
  lastTotalRx = sink->GetTotalRx ();
  averageThroughput += thr;
  return thr;
}

void
CalculateThroughput (void)
{
  double totalThr = 0;
  double thr;
  if (!csv)
    {
      string duration = to_string_with_precision<double> (Simulator::Now ().GetSeconds () - 0.1, 1)
        + " - " + to_string_with_precision<double> (Simulator::Now ().GetSeconds (), 1);
      std::cout << std::left << std::setw (12) << duration;
      for (CommunicationPairList_I it = communicationPairList.begin (); it != communicationPairList.end (); it++)
        {
          thr = CalculateSingleStreamThroughput (it->second.packetSink, it->second.totalRx, it->second.throughput);
          totalThr += thr;
          std::cout << std::left << std::setw (12) << thr;
        }
      std::cout << std::left << std::setw (12) << totalThr
                << std::left << std::setw (12) << lossModelRaytracing->GetCurrentTraceIndex () << std::endl;
    }
  else
    {
      std::cout << to_string_with_precision<double> (Simulator::Now ().GetSeconds (), 1);
      for (CommunicationPairList_I it = communicationPairList.begin (); it != communicationPairList.end (); it++)
        {
          thr = CalculateSingleStreamThroughput (it->second.packetSink, it->second.totalRx, it->second.throughput);
          totalThr += thr;
          std::cout << "," << thr;
        }
      std::cout << "," << totalThr << std::endl;
    }
  Simulator::Schedule (MilliSeconds (100), &CalculateThroughput);
}

Ptr<WifiNetDevice>
CreateAccessPoint (Ptr<Node> apNode, Ssid ssid,
                   DmgWifiHelper &wifi, DmgWifiPhyHelper &wifiPhy)
{
  DmgWifiMacHelper wifiMac = DmgWifiMacHelper::Default ();

  wifiMac.SetType ("ns3::DmgApWifiMac",
                   "Ssid", SsidValue (ssid),
                   "BeaconInterval", TimeValue (MicroSeconds (102400)),
                   "BE_MaxAmpduSize", UintegerValue (mpduAggregationSize),
                   "BE_MaxAmsduSize", UintegerValue (msduAggregationSize),
                   "SSSlotsPerABFT", UintegerValue (8), "SSFramesPerSlot", UintegerValue (16),
                   "EnableBeaconJitter", BooleanValue (enableJitter),
                   "ATIPresent", BooleanValue (false));

  if (enableJitter)
    {
      wifiMac.SetAttrbiute ("BeaconJitter", StringValue (beaconJitter));
    }

  NetDeviceContainer apDevice = wifi.Install (wifiPhy, wifiMac, apNode);

  return (StaticCast<WifiNetDevice> (apDevice.Get (0)));
}

void
SLSCompleted (Ptr<OutputStreamWrapper> stream,  Ptr<Parameters> parameters, Mac48Address address,  ChannelAccessPeriod accessPeriod,
              BeamformingDirection beamformingDirection, bool isInitiatorTxss, bool isResponderTxss,
              SECTOR_ID sectorId, ANTENNA_ID antennaId)
{
  *stream->GetStream () << parameters->srcNodeID + 1 << "," << map_Mac2ID[address] + 1 << ","
                        << lossModelRaytracing->GetCurrentTraceIndex () << ","
                        << uint16_t (sectorId) << "," << uint16_t (antennaId)  << ","
                        << parameters->wifiMac->GetTypeOfStation ()  << ","
                        << map_Mac2ID[parameters->wifiMac->GetBssid ()] + 1  << ","
                        << Simulator::Now ().GetSeconds () << std::endl;

  if (!csv)
    {
      std::cout << "DMG STA " << parameters->wifiMac->GetAddress () << " completed SLS phase with DMG STA " << address << std::endl;
      std::cout << "Best Tx Antenna Configuration: SectorID=" << uint16_t (sectorId) << ", AntennaID=" << uint16_t (antennaId) << std::endl;
    }
}

void
StationAssoicated (Ptr<Node> node, Ptr<DmgWifiMac> staWifiMac, Mac48Address address, uint16_t aid)
{
  if (!csv)
    {
      std::cout << "DMG STA " << staWifiMac->GetAddress () << " associated with DMG PCP/AP " << address
                << ", Association ID (AID) = " << aid << std::endl;
    }
  CommunicationPairList_I it = communicationPairList.find (node);
  if (it != communicationPairList.end ())
    {
      it->second.startTime = Simulator::Now ();
      it->second.srcApp->StartApplication ();
    }
  else
    {
      NS_FATAL_ERROR ("Could not find application to run.");
    }
}

void
StationDeassoicated (Ptr<Node> node, Ptr<DmgWifiMac> staWifiMac, Mac48Address address)
{
  if (!csv)
    {
      std::cout << "DMG STA " << staWifiMac->GetAddress () << " deassociated from DMG PCP/AP " << address << std::endl;
    }
  CommunicationPairList_I it = communicationPairList.find (node);
  if (it != communicationPairList.end ())
    {
      it->second.srcApp->StopApplication ();
    }
  else
    {
      NS_FATAL_ERROR ("Could not find application to delete.");
    }
}

CommunicationPair
InstallApplications (Ptr<Node> srcNode, Ptr<Node> dstNode, Ipv4Address address)
{
  CommunicationPair commPair;

  /* Install TCP/UDP Transmitter on the source node */
  Address dest (InetSocketAddress (address, 9999));
  ApplicationContainer srcApp;
  if (applicationType == "onoff")
    {
      OnOffHelper src (socketType, dest);
      src.SetAttribute ("MaxBytes", UintegerValue (maxPackets));
      src.SetAttribute ("PacketSize", UintegerValue (packetSize));
      src.SetAttribute ("OnTime", StringValue ("ns3::ConstantRandomVariable[Constant=1e6]"));
      src.SetAttribute ("OffTime", StringValue ("ns3::ConstantRandomVariable[Constant=0]"));
      src.SetAttribute ("DataRate", DataRateValue (DataRate (dataRate)));
      srcApp = src.Install (srcNode);
    }
  else if (applicationType == "bulk")
    {
      BulkSendHelper src (socketType, dest);
      srcApp = src.Install (srcNode);
    }
  srcApp.Start (Seconds (simulationTime + 1));
  srcApp.Stop (Seconds (simulationTime));
  commPair.srcApp = srcApp.Get (0);

  /* Install Simple TCP/UDP Server on the destination node */
  PacketSinkHelper sinkHelper (socketType, InetSocketAddress (Ipv4Address::GetAny (), 9999));
  ApplicationContainer sinkApp = sinkHelper.Install (dstNode);
  commPair.packetSink = StaticCast<PacketSink> (sinkApp.Get (0));
  sinkApp.Start (Seconds (0.0));

  return commPair;
}

NetDeviceContainer
InstallMAC_Layer (Ptr<Node> node, DmgWifiHelper &wifi, DmgWifiPhyHelper &wifiPhy, std::string apName)
{
  DmgWifiMacHelper wifiMac = DmgWifiMacHelper::Default ();
  wifiMac.SetType ("ns3::DmgStaWifiMac",
                   "Ssid", SsidValue (Ssid (apName)), "ActiveProbing", BooleanValue (false),
                   "BE_MaxAmpduSize", UintegerValue (mpduAggregationSize),
                   "BE_MaxAmsduSize", UintegerValue (msduAggregationSize),
                   "RSSRetryLimit", UintegerValue (32),
                   "RSSBackoff", UintegerValue (1));
  return wifi.Install (wifiPhy, wifiMac, node);
}

/*** Beamforming CBAP ***/
uint16_t biThreshold = 10;                                    /* BI Threshold to trigger TxSS TXOP. */
std::map<Mac48Address, uint16_t> biCounter;                   /* Number of beacon intervals that have passed. */

void
DataTransmissionIntervalStarted (Ptr<DmgApWifiMac> apWifiMac, Ptr<DmgStaWifiMac> staWifiMac, Mac48Address address, Time)
{
  if (apWifiMac->GetWifiRemoteStationManager ()->IsAssociated (staWifiMac->GetAddress ()) > 0)
    {
      uint16_t counter = biCounter[address];
      counter++;
      if (counter == biThreshold)
        {
          staWifiMac->InitiateTxssCbap (address);
          counter = 0;
        }
      biCounter[address] = counter;
    }
}

void
MacRxOk (Ptr<DmgWifiMac> WifiMac, Ptr<OutputStreamWrapper> stream,
         WifiMacType type, Mac48Address address, double snrValue)
{
  if (type == WIFI_MAC_QOSDATA)
    {
      *stream->GetStream () << Simulator::Now ().GetNanoSeconds () << ","
                            << address << ","
                            << WifiMac->GetAddress () << ","
                            << snrValue << std::endl;
    }
}

int
main (int argc, char *argv[])
{
  uint32_t bufferSize = 131072;                           /* TCP Send/Receive Buffer Size. */
  uint32_t queueSize = 1000;                              /* Wifi MAC Queue Size. */
  bool frameCapture = false;                              /* Use a frame capture model. */
  double frameCaptureMargin = 10;                         /* Frame capture margin in dB. */
  string phyMode = "DMG_MCS12";                           /* Type of the Physical Layer. */
  uint32_t parallelLinks = 2;                             /* The number of parallel links. */
  uint32_t snapShotLength = std::numeric_limits<uint32_t>::max ();       /* The maximum PCAP Snapshot Length */
  bool verbose = false;                                   /* Print Logging Information. */
  bool pcapTracing = false;                               /* PCAP Tracing is enabled or not. */
  std::map<std::string, std::string> tcpVariants;         /* List of the TCP Variants */
  bool enableMobility = false;                            /* Enable mobility. */
  std::string arrayConfig = "28";                         /* Phased antenna array configuration. */
  std::string qdChannelFolder = "SpatialSharingMobility"; /* The name of the folder containing the QD-Channel files. */

  /** TCP Variants **/
  tcpVariants.insert (std::make_pair ("NewReno",       "ns3::TcpNewReno"));
  tcpVariants.insert (std::make_pair ("Hybla",         "ns3::TcpHybla"));
  tcpVariants.insert (std::make_pair ("HighSpeed",     "ns3::TcpHighSpeed"));
  tcpVariants.insert (std::make_pair ("Vegas",         "ns3::TcpVegas"));
  tcpVariants.insert (std::make_pair ("Scalable",      "ns3::TcpScalable"));
  tcpVariants.insert (std::make_pair ("Veno",          "ns3::TcpVeno"));
  tcpVariants.insert (std::make_pair ("Bic",           "ns3::TcpBic"));
  tcpVariants.insert (std::make_pair ("Westwood",      "ns3::TcpWestwood"));
  tcpVariants.insert (std::make_pair ("WestwoodPlus",  "ns3::TcpWestwoodPlus"));

  /* Command line argument parser setup. */
  CommandLine cmd;
  cmd.AddValue ("applicationType", "Type of the Tx Application: onoff or bulk", applicationType);
  cmd.AddValue ("packetSize", "Application packet size in bytes", packetSize);
  cmd.AddValue ("dataRate", "Application data rate", dataRate);
  cmd.AddValue ("maxPackets", "Maximum number of packets to send", maxPackets);
  cmd.AddValue ("tcpVariant", "Transport protocol to use: TcpTahoe, TcpReno, TcpNewReno, TcpWestwood, TcpWestwoodPlus", tcpVariant);
  cmd.AddValue ("socketType", "Type of the Socket (ns3::TcpSocketFactory, ns3::UdpSocketFactory)", socketType);
  cmd.AddValue ("bufferSize", "TCP Buffer Size (Send/Receive) in Bytes", bufferSize);
  cmd.AddValue ("msduAggregation", "The maximum aggregation size for A-MSDU in Bytes", msduAggregationSize);
  cmd.AddValue ("mpduAggregation", "The maximum aggregation size for A-MPDU in Bytes", mpduAggregationSize);
  cmd.AddValue ("queueSize", "The maximum size of the Wifi MAC Queue", queueSize);
  cmd.AddValue ("frameCapture", "Use a frame capture model", frameCapture);
  cmd.AddValue ("frameCaptureMargin", "Frame capture model margin in dB", frameCaptureMargin);
  cmd.AddValue ("phyMode", "802.11ad PHY Mode", phyMode);
  cmd.AddValue ("enableJitter", "Enable Beacon Interval Jitter to randomize Beacon Interval start time", enableJitter);
  cmd.AddValue ("beaconJitter", "Beacon Jitter value in MicroSeconds", beaconJitter);
  cmd.AddValue ("parallelLinks", "The number of parallel links", parallelLinks);
  cmd.AddValue ("biThreshold", "BI Threshold to trigger beamforming training", biThreshold);
  cmd.AddValue ("verbose", "turn on all WifiNetDevice log components", verbose);
  cmd.AddValue ("simulationTime", "Simulation time in seconds", simulationTime);
  cmd.AddValue ("snapShotLength", "The maximum PCAP Snapshot Length", snapShotLength);
  cmd.AddValue ("qdChannelFolder", "The name of the folder containing the QD-Channel files", qdChannelFolder);
  cmd.AddValue ("pcap", "Enable PCAP Tracing", pcapTracing);
  cmd.AddValue ("arrayConfig", "Antenna array configuration", arrayConfig);

  cmd.AddValue ("enableMobility", "Whether to enable mobility or simulate static scenario", enableMobility);
  cmd.AddValue ("csv", "Enable CSV output instead of plain text. This mode will suppress all the messages related statistics and events.", csv);
  cmd.Parse (argc, argv);

  /* Global params: no fragmentation, no RTS/CTS, fixed rate for all packets */
  Config::SetDefault ("ns3::WifiRemoteStationManager::FragmentationThreshold", StringValue ("999999"));
  Config::SetDefault ("ns3::WifiRemoteStationManager::RtsCtsThreshold", StringValue ("999999"));
  Config::SetDefault ("ns3::QueueBase::MaxPackets", UintegerValue (queueSize));

  /*** Configure TCP Options ***/
  /* Select TCP variant */
  std::map<std::string, std::string>::const_iterator iter = tcpVariants.find (tcpVariant);
  NS_ASSERT_MSG (iter != tcpVariants.end (), "Cannot find Tcp Variant");
  TypeId tid = TypeId::LookupByName (iter->second);
  Config::SetDefault ("ns3::TcpL4Protocol::SocketType", TypeIdValue (tid));
  if (tcpVariant.compare ("Westwood") == 0)
    {
      Config::SetDefault ("ns3::TcpWestwood::ProtocolType", EnumValue (TcpWestwood::WESTWOOD));
      Config::SetDefault ("ns3::TcpWestwood::FilterType", EnumValue (TcpWestwood::TUSTIN));
    }
  else if (tcpVariant.compare ("WestwoodPlus") == 0)
    {
      Config::SetDefault ("ns3::TcpWestwood::ProtocolType", EnumValue (TcpWestwood::WESTWOODPLUS));
      Config::SetDefault ("ns3::TcpWestwood::FilterType", EnumValue (TcpWestwood::TUSTIN));
    }

  /* Configure TCP Segment Size */
  Config::SetDefault ("ns3::TcpSocket::SegmentSize", UintegerValue (packetSize));
  Config::SetDefault ("ns3::TcpSocket::SndBufSize", UintegerValue (bufferSize));
  Config::SetDefault ("ns3::TcpSocket::RcvBufSize", UintegerValue (bufferSize));

  /**** WifiHelper is a meta-helper: it helps creates helpers ****/
  DmgWifiHelper wifi;

  /* Basic setup */
  wifi.SetStandard (WIFI_PHY_STANDARD_80211ad);

  /* Turn on logging */
  if (verbose)
    {
      wifi.EnableLogComponents ();
      LogComponentEnable ("EvaluateMultiBSSOperation", LOG_LEVEL_ALL);
    }


  /**** Set up Channel ****/
  Ptr<MultiModelSpectrumChannel> spectrumChannel = CreateObject<MultiModelSpectrumChannel> ();
  lossModelRaytracing  = CreateObject<QdPropagationLossModel> ();
  Ptr<QdPropagationDelay> propagationDelayRayTracing = CreateObject<QdPropagationDelay> ();
  lossModelRaytracing->SetAttribute ("QDModelFolder", StringValue ("DmgFiles/QdChannel/" + qdChannelFolder + "/"));
  propagationDelayRayTracing->SetAttribute ("QDModelFolder", StringValue ("DmgFiles/QdChannel/" + qdChannelFolder + "/"));
  spectrumChannel->AddSpectrumPropagationLossModel (lossModelRaytracing);
  spectrumChannel->SetPropagationDelayModel (propagationDelayRayTracing);
  if (enableMobility)
    {
      lossModelRaytracing->SetAttribute ("Speed", DoubleValue (0.1));
      propagationDelayRayTracing->SetAttribute ("Speed", DoubleValue (0.1));
    }
  else
    {
      lossModelRaytracing->SetAttribute ("Speed", DoubleValue (0));
      propagationDelayRayTracing->SetAttribute ("Speed", DoubleValue (0));
    }

  /**** Setup physical layer ****/
  SpectrumDmgWifiPhyHelper wifiPhy = SpectrumDmgWifiPhyHelper::Default ();
  wifiPhy.SetChannel (spectrumChannel);
  /* All nodes transmit at 10 dBm == 10 mW, no adaptation */
  wifiPhy.Set ("TxPowerStart", DoubleValue (10.0));
  wifiPhy.Set ("TxPowerEnd", DoubleValue (10.0));
  wifiPhy.Set ("TxPowerLevels", UintegerValue (1));
  if (frameCapture)
    {
      /* Frame Capture Model */
      wifiPhy.Set ("FrameCaptureModel", StringValue ("ns3::SimpleFrameCaptureModel"));
      Config::SetDefault ("ns3::SimpleFrameCaptureModel::Margin", DoubleValue (frameCaptureMargin));
    }
  /* Set operating channel */
  wifiPhy.Set ("ChannelNumber", UintegerValue (2));
  /* Set error model */
  wifiPhy.SetErrorRateModel ("ns3::DmgErrorModel",
                             "FileName", StringValue ("DmgFiles/ErrorModel/LookupTable_1458.txt"));
  /* Sensitivity model includes implementation loss and noise figure */
  wifiPhy.Set ("CcaMode1Threshold", DoubleValue (-70));
  wifiPhy.Set ("EnergyDetectionThreshold", DoubleValue (-70 + 3));
  /* Set default algorithm for all nodes to be constant rate */
  wifi.SetRemoteStationManager ("ns3::ConstantRateWifiManager", "DataMode", StringValue (phyMode));

  /* Make four nodes and set them up with PHY and MAC */
  NodeContainer apWifiNodes;
  apWifiNodes.Create (parallelLinks);

  NodeContainer staWifiNodes;
  staWifiNodes.Create (parallelLinks);

  /* Set Parametric Codebook for the DMG AP */
  wifi.SetCodebook ("ns3::CodebookParametric",
                    "FileName", StringValue ("DmgFiles/Codebook/CODEBOOK_URA_AP_" + arrayConfig + "x.txt"));

  /* Install DMG PCP/AP Nodes */
  NetDeviceContainer apDevices;
  for (uint32_t i = 0; i < parallelLinks; i++)
    {
      apDevices.Add (CreateAccessPoint (apWifiNodes.Get (i), Ssid ("AP" + std::to_string (i)), wifi, wifiPhy));
    }

  /* Set Parametric Codebook for the DMG STA */
  wifi.SetCodebook ("ns3::CodebookParametric",
                    "FileName", StringValue ("DmgFiles/Codebook/CODEBOOK_URA_STA_" + arrayConfig + "x.txt"));

  /* Install DMG STA Nodes */
  NetDeviceContainer staDevices;
  for (uint32_t i = 0; i < parallelLinks; i++)
    {
      staDevices.Add (InstallMAC_Layer (staWifiNodes.Get (i), wifi, wifiPhy, "AP" + std::to_string (i)));
    }

  /* Setting mobility model */
  MobilityHelper mobility;
  mobility.SetMobilityModel ("ns3::ConstantPositionMobilityModel");
  mobility.Install (apWifiNodes);
  mobility.Install (staWifiNodes);

  /* Internet stack*/
  InternetStackHelper stack;
  stack.Install (apWifiNodes);
  stack.Install (staWifiNodes);

  Ipv4AddressHelper address;
  address.SetBase ("10.0.0.0", "255.255.255.0");
  Ipv4InterfaceContainer apInterfaces;
  apInterfaces = address.Assign (apDevices);
  address.Assign (staDevices);

  /* We do not want any ARP packets */
  PopulateArpCache ();

  /** Install Applications **/
  /* DMG STA -->  DMG AP */
  for (uint32_t i = 0; i < parallelLinks; i++)
    {
      communicationPairList[staWifiNodes.Get (i)] = InstallApplications (staWifiNodes.Get (i), apWifiNodes.Get (i),
                                                                         apInterfaces.GetAddress (i));
    }

  /* MAP MAC Addresses to NodeIDs */
  NetDeviceContainer devices;
  Ptr<WifiNetDevice> netDevice;
  devices.Add (apDevices);
  devices.Add (staDevices);
  for (uint32_t i = 0; i < devices.GetN (); i++)
    {
      netDevice = StaticCast<WifiNetDevice> (devices.Get (i));
      map_Mac2ID[netDevice->GetMac ()->GetAddress ()] = netDevice->GetNode ()->GetId ();
    }

  /* Connect DMG PCP/AP and DMG STA Traces */
  Ptr<WifiNetDevice> wifiNetDevice;
  Ptr<DmgApWifiMac> dmgApWifiMac;
  Ptr<DmgStaWifiMac> dmgStaWifiMac;
  Ptr<WifiRemoteStationManager> apRemoteStationManager;
  uint32_t nodeId;

  AsciiTraceHelper ascii;
  Ptr<OutputStreamWrapper> outputSlsPhase = ascii.CreateFileStream ("slsResults" + arrayConfig + ".csv");
  *outputSlsPhase->GetStream () << "SRC_ID,DST_ID,TRACE_IDX,SECTOR_ID,ANTENNA_ID,ROLE,BSS_ID,Timestamp" << std::endl;

  /* Get SNR Traces */
  Ptr<OutputStreamWrapper> snrStream = ascii.CreateFileStream ("snrValues.csv");
  *snrStream->GetStream () << "TIME,SRC,DST,SNR" << std::endl;

  for (uint32_t i = 0; i < apDevices.GetN (); i++)
    {
      /* DMG STA Traces */
      wifiNetDevice = StaticCast<WifiNetDevice> (staDevices.Get (i));
      dmgStaWifiMac = StaticCast<DmgStaWifiMac> (wifiNetDevice->GetMac ());
      dmgStaWifiMac->TraceConnectWithoutContext ("Assoc", MakeBoundCallback (&StationAssoicated, staWifiNodes.Get (i), dmgStaWifiMac));
      dmgStaWifiMac->TraceConnectWithoutContext ("DeAssoc", MakeBoundCallback (&StationDeassoicated, staWifiNodes.Get (i), dmgStaWifiMac));
      Ptr<Parameters> parametersSta = Create<Parameters> ();
      nodeId = wifiNetDevice->GetNode ()->GetId ();
      parametersSta->srcNodeID = nodeId;
      parametersSta->wifiMac = dmgStaWifiMac;
      dmgStaWifiMac->TraceConnectWithoutContext ("SLSCompleted", MakeBoundCallback (&SLSCompleted,  outputSlsPhase, parametersSta));

      /* DMG PCP/AP Traces */
      wifiNetDevice = StaticCast<WifiNetDevice> (apDevices.Get (i));
      dmgApWifiMac = StaticCast<DmgApWifiMac> (wifiNetDevice->GetMac ());
      apRemoteStationManager = wifiNetDevice->GetRemoteStationManager ();
      Ptr<Parameters> parametersAp = Create<Parameters> ();
      nodeId = wifiNetDevice->GetNode ()->GetId ();
      parametersAp->srcNodeID = nodeId;
      parametersAp->wifiMac = dmgStaWifiMac;
      dmgApWifiMac->TraceConnectWithoutContext ("SLSCompleted", MakeBoundCallback (&SLSCompleted, outputSlsPhase,  parametersAp));
      dmgApWifiMac->TraceConnectWithoutContext ("DTIStarted", MakeBoundCallback (&DataTransmissionIntervalStarted,
                                                                                 dmgApWifiMac, dmgStaWifiMac));
      apRemoteStationManager->TraceConnectWithoutContext ("MacRxOK", MakeBoundCallback (&MacRxOk, dmgApWifiMac, snrStream));

      biCounter[dmgApWifiMac->GetAddress ()] = 0;
    }

  /* Enable Traces */
  if (pcapTracing)
    {
      wifiPhy.SetPcapDataLinkType (YansWifiPhyHelper::DLT_IEEE802_11_RADIO);
      wifiPhy.SetSnapshotLength (snapShotLength);
      wifiPhy.EnablePcap ("Traces/AccessPoint", apDevices.Get (1), false);
      wifiPhy.EnablePcap ("Traces/STA", staDevices.Get (1), false);
    }

  /* Install FlowMonitor on all nodes */
  FlowMonitorHelper flowmon;
  Ptr<FlowMonitor> monitor = flowmon.InstallAll ();

  /* Print Output */
  if (!csv)
    {
      std::cout << "Application Layer Throughput per Communicating Pair [Mbps]" << std::endl;
      std::cout << std::left << std::setw (12) << "Time [s]";
      string columnName;
      for (uint8_t i = 0; i < communicationPairList.size (); i++)
        {
          columnName = "Pair (" + std::to_string (i + 1) + ")";
          std::cout << std::left << std::setw (12) << columnName;
        }
      std::cout << std::left << std::setw (12) << "Total"
                << std::left << std::setw (12) << "Trace Index" << std::endl;
    }

  /* Schedule Throughput Calulcations */
  Simulator::Schedule (Seconds (0.1), &CalculateThroughput);

  Simulator::Stop (Seconds (simulationTime + 0.101));
  Simulator::Run ();
  Simulator::Destroy ();

  if (!csv)
    {
      /* Print per flow statistics */
      monitor->CheckForLostPackets ();
      Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier> (flowmon.GetClassifier ());
      FlowMonitor::FlowStatsContainer stats = monitor->GetFlowStats ();
      for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin (); i != stats.end (); ++i)
        {
          Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow (i->first);
          std::cout << "Flow " << i->first << " (" << t.sourceAddress << " -> " << t.destinationAddress << ")" << std::endl;
          std::cout << "  Tx Packets: " << i->second.txPackets << std::endl;
          std::cout << "  Tx Bytes:   " << i->second.txBytes << std::endl;
          std::cout << "  TxOffered:  " << i->second.txBytes * 8.0 / ((simulationTime - 0.1) * 1e6)  << " Mbps" << std::endl;
          std::cout << "  Rx Packets: " << i->second.rxPackets << std::endl;
          std::cout << "  Rx Bytes:   " << i->second.rxBytes << std::endl;
          std::cout << "  Throughput: " << i->second.rxBytes * 8.0 / ((simulationTime - 0.1) * 1e6)  << " Mbps" << std::endl;
        }

      /* Print Application Layer Results Summary */
      std::cout << "\nApplication Layer Statistics:" << std::endl;
      Ptr<OnOffApplication> onoff;
      Ptr<BulkSendApplication> bulk;
      uint16_t communicationLinks = 1;
      for (CommunicationPairList_I it = communicationPairList.begin (); it != communicationPairList.end (); it++)
        {
          std::cout << "Communication Link (" << communicationLinks << ") Statistics:" << std::endl;
          if (applicationType == "onoff")
            {
              onoff = StaticCast<OnOffApplication> (it->second.srcApp);
              std::cout << "  Tx Packets: " << onoff->GetTotalTxPackets () << std::endl;
              std::cout << "  Tx Bytes:   " << onoff->GetTotalTxBytes () << std::endl;
            }
          else
            {
              bulk = StaticCast<BulkSendApplication> (it->second.srcApp);
              std::cout << "  Tx Packets: " << bulk->GetTotalTxPackets () << std::endl;
              std::cout << "  Tx Bytes:   " << bulk->GetTotalTxBytes () << std::endl;
            }
          Ptr<PacketSink> packetSink = StaticCast<PacketSink> (it->second.packetSink);
          std::cout << "  Rx Packets: " << packetSink->GetTotalReceivedPackets () << std::endl;
          std::cout << "  Rx Bytes:   " << packetSink->GetTotalRx () << std::endl;
          std::cout << "  Throughput: " << packetSink->GetTotalRx () * 8.0 / ((simulationTime - it->second.startTime.GetSeconds ()) * 1e6)
                    << " Mbps" << std::endl;
          communicationLinks++;
        }
    }

  return 0;
}
